---
title: "__Temporal Overlap Analyses of Tropical Arctiidae Species__"
author: "Jonas Geschke and Sören Greule"
date: "Winter semester 2015/16"
output:
  pdf_document:
    toc: yes
documentclass: article
classoption: a4paper
---

- - - - - - - - - -

# Introduction
_This skript is the outcome of a selected topic within the MSc Environmental Scienes, Faculty of Environment and Natural Resources, University of Freiburg. The selected topic is supervised by Dr Tim Burzlaff._

The script is about the analysis of monitoring data from both Costa Rica (locations: El Bosque Nuevo Butterfly Farm and the private home of P. Gloor, near San José) and Peru (location: Panguana). The main interest is about looking for existing temporal niche and community interactions within species of Arctiinae and Ithomiini species.

The main analysis approach comes from the paper "Temporal Overlap and Co-Occurrence in a Guild of Sub-Tropical Tephritid Fruit Flies" by Lopes GN, Souza-Filho MF, Gotelli NJ, Lemos LJU, Godoy WAC and Zucchi RA (2015) in PLoS ONE 10(7): e0132124, [doi:10.1371/journal.pone.0132124](http://journals.plos.org/plosone/article?id=10.1371/journal.pone.0132124). We concentrate on their idea about the niche overlap analyses.
The data used in our analyses come from the long-term monitoring trapping of the Chair of Forest Zoology and Entomology, University of Freiburg, and was undertaken by several staff members and student assistants.


- - - - - - - - - -
# Script

## Defining general settings

In here, we set the working directory, which one might have to adapt or change in order to get this skript running. Further, we provide the code for installing all needed packages and activate them.

```{r, message=FALSE}
# Setting the working directory
setwd("~/Studium/MSc/3. Semester/Temporal_niche_analyses/Git")

###### Installing packages (if needed: delete the hashtag in front of the code!) ######
# install.packages("lubridate")
# install.packages("ggplot2")
# install.packages("reshape")
# install.packages("EcoSimR")
#######################################################################################

# Loading packages
library(lubridate)
library(ggplot2)
library(reshape)
library(EcoSimR)
```


## Revising the original data

Now we read the original data and directly resave it as an archive datafile. In the working datafile `Gdata`, we rename the columns for easier handling.

```{r, results='hide'}
# Load the original datatable
Gdata <- read.csv2("IndID Auszug 01.Sep 15 All In.csv",
                   header = T,
                   sep = ";",
                   na.strings = "")

# Resaving original datatable as archive table
GdataORIG <- Gdata

# Show original column names
names(Gdata)

# Renaming columns
names(Gdata)[names(Gdata) == "DataSet"]     <- "taxon"
names(Gdata)[names(Gdata) == "Bemerkung1"]  <- "notes"
names(Gdata)[names(Gdata) == "day_night"]   <- "light"
names(Gdata)[names(Gdata) == "Art."]        <- "spp"
names(Gdata)[names(Gdata) == "FangDatum"]   <- "date"
names(Gdata)[names(Gdata) == "FangOrt"]     <- "site"
names(Gdata)[names(Gdata) == "FangZeit"]    <- "time"
names(Gdata)[names(Gdata) == "IndID"]       <- "iid"
names(Gdata)[names(Gdata) == "Sex"]         <- "sex"
names(Gdata)[names(Gdata) == "Typ1"]        <- "trap"
names(Gdata)[names(Gdata) == "Vertrauen"]   <- "trust"

# Control new column names
names(Gdata)
```


Now we have a table that we can further process.
First of all, we do not need the columns "notes" and "iid" (individual ID) and correct some oversight mistakes within the datatable. Also, we do have 2 levels of trust within the whole datatable - 1 and 2. Trust level "2" is good, level "1" not so much. Those datapoint with no trust level at all are deleted at once.

```{r, results='hide'}
# Deleting the "notes" and "iid" columns
Gdata$notes <- NULL
Gdata$iid <- NULL
names(Gdata)

# Delete all rows, where the trust level is equal 0 (= NA)
Gdata <- subset(Gdata, Gdata$trust != "NA")
Gdata <- droplevels(Gdata)
summary(Gdata)

# Correcting the "light" cells
summary(Gdata$light)
Gdata$light[Gdata$light == "atg"]           <- "tag"
Gdata$light[Gdata$light == "tag "]          <- "tag"
Gdata$light[Gdata$light == "nacht\n"]       <- "nacht"
Gdata$light[Gdata$light == "nachts"]        <- "nacht"
Gdata <- droplevels(Gdata)
summary(Gdata$light)
### There are further values we need to think about! ("m" and time)

# Correcting the "site" cells
summary(Gdata$site)
Gdata$site[Gdata$site == "CR"]              <- "EBN"
Gdata$site[Gdata$site == "EBN\n"]           <- "EBN"
Gdata$site[Gdata$site == "GLOOR"]           <- "PG"
Gdata <- droplevels(Gdata)
summary(Gdata$site)

# Correcting the "sex" cells
summary(Gdata$sex)
Gdata$sex[Gdata$sex == "f "]                <- "f"
Gdata$sex[Gdata$sex == "w"]                 <- "f"
Gdata <- droplevels(Gdata)
summary(Gdata$sex)
### There are further values we need to think about! ("?" and "f?")
```


## Processing the data for further uses

For getting an overview plot of our data, we sort the whole datatable by date. Thus, we add two columns. Each one for the year and for the month. Afterwards we would like to produce a first plot, so we also add two columns containing information about the month and the day number.

```{r, results='hide'}
# Creating the column "year"
Gdata <- cbind(Gdata, "year" = format(as.Date(Gdata$date, "%d.%m.%Y"), "%Y"))

# Creating the column "month"
Gdata <- cbind(Gdata, "month" = format(as.Date(Gdata$date, "%d.%m.%Y"), "%m"))

# Creating a column, in which the month is written out
Gdata <- cbind(Gdata, "monat" = format(as.Date(Gdata$date, "%d.%m.%Y"), "%B"))

# Creating a column, in which for each day we define the day number within a year
# Here, the package "lubridate" is needed
Gdata <- cbind(Gdata, "day_nr" = yday(as.Date(Gdata$date, "%d.%m.%Y")))

# Sorting whole datatable by month
Gdata <- Gdata[order(Gdata$month),]
```


Also, for later `cast`-processing, we create a "value" column.

```{r, results='hide'}
# Creating the "value" column, which contains availability information (yes/no)
Gdata <- cbind(Gdata, "value" = 1)
```




Now that we organized the datatable for a bit, we are ready to create a first overview plot about how many individuals were trapped thoughout the years.

```{r, results='hide', fig.show='hide'}
# Creating a colour palette for the plot
colourpalette10 <- c("#596137",
                     "#BD57C7",
                     "#7FCD4E",
                     "#BF543A",
                     "#A3B1BF",
                     "#CFB253",
                     "#C55783",
                     "#4F3647",
                     "#7374BE",
                     "#84CAA0")

# Creating plot0. This plot shows the whole data (also NAs)!
# Here, the package "ggplot2" is needed
plotORIG <- ggplot(Gdata, aes(x = day_nr, fill = monat))+
  scale_fill_manual(name = "Month", values = colourpalette10,
                    breaks = c("Januar",
                               "Februar",
                               "März",
                               "April",
                               "Mai",
                               "Juni",
                               "Juli",
                               "August",
                               "September",
                               "Oktober"))+
  geom_histogram(binwidth = 1)+
  facet_wrap(site ~ year, ncol = 1)+
  theme(axis.text.x = element_text(angle = 90, hjust = 1))+
  labs(title = "Number of trapped individuals per site, including NAs",
       x = "Day of the year",
       y = "No of trapped Arctiinae individuals")+
  scale_x_continuous(expand = c(0,0),
                     breaks = seq(0, 365, 7),
                     limits = c(0, 365))
plotORIG
```


As we can see in this `plotORIG`, is does not make sense to include those data points, where we neither know the trapping site nor the trapping year.
So next, we delete those rows out of the datatable where this information is not noted. Further, we would like to have data rows with Arctiinae and 2nd trust level only. So we delete all other datapoints. Finally, as it does not make sense to keep them, we delete all rows where we do not know the species number.

```{r, results='hide'}
# Deleting all rows, where the taxon is not "Arct", the "spp" and "site" are not noted, the trust level is not "2" and where we dont have a specific trapping "year" noted
Gdata <- subset(Gdata, taxon == "Arct")
Gdata <- subset(Gdata, spp != "NA")
Gdata <- subset(Gdata, site != "NA")
Gdata <- subset(Gdata, trust == "2")
Gdata <- subset(Gdata, year != "NA")
Gdata <- droplevels(Gdata)
```

Now, we repeat plotting this. This plot includes all the datapoints that probably are more interesting to look at, as all basic information are given we need for further analyses and interpretation.

```{r, fig.cap='plot2', fig.ext='pdf', fig.height=27, fig.width=17, dpi=300}
# Creating overview_plot
# Here, the package "ggplot2" is needed
overview_plot <- ggplot(Gdata, aes(x = day_nr, fill = monat))+
  scale_fill_manual(name = "Month", values = colourpalette10,
                    breaks = c("Januar",
                               "Februar",
                               "März",
                               "April",
                               "Mai",
                               "Juni",
                               "Juli",
                               "August",
                               "September",
                               "Oktober"))+
  geom_histogram(binwidth = 1)+
  facet_wrap(site ~ year, ncol = 1)+
  theme(axis.text.x = element_text(angle = 90, hjust = 1))+
  labs(title = "Number of trapped Arctiinae individuals 2007-2015
       in EBN and 2010, 2013 & 2015 in Peru Panguana",
       x = "Day of the year",
       y = "No of trapped Arctiinae individuals")+
  scale_x_continuous(expand = c(0,0),
                     breaks = seq(0, 365, 7),
                     limits = c(0, 365))
overview_plot
```



## Preparing the data for further analyses

Creating subset datasets for each site, `Gdata_EBN` and `Gdata_PP`.

```{r, eval=FALSE}
# Creating a subset, which only contains data from EBN
Gdata_EBN <- subset(Gdata, site == "EBN")
Gdata_PP <- subset(Gdata, site == "PP")

# Creating subsets for each year per site
Gdata_EBN_2007 <- subset(Gdata_EBN, year == "2007")
Gdata_EBN_2008 <- subset(Gdata_EBN, year == "2008")
Gdata_EBN_2009 <- subset(Gdata_EBN, year == "2009")
Gdata_EBN_2010 <- subset(Gdata_EBN, year == "2010")
Gdata_EBN_2011 <- subset(Gdata_EBN, year == "2011")
Gdata_EBN_2012 <- subset(Gdata_EBN, year == "2012")
Gdata_EBN_2013 <- subset(Gdata_EBN, year == "2013")
Gdata_EBN_2014 <- subset(Gdata_EBN, year == "2014")
Gdata_EBN_2015 <- subset(Gdata_EBN, year == "2015")
Gdata_PP_2010 <- subset(Gdata_PP, year == "2010")
Gdata_PP_2013 <- subset(Gdata_PP, year == "2013")
Gdata_PP_2015 <- subset(Gdata_PP, year == "2015")
```


### Subsetting function bases

```{r, eval=FALSE}
# dataset_split <- function(data, light = FALSE, site = FALSE, trap = FALSE, month_start = "01", month_end = "12"){}

# sex_rowsplit <- function(data){}

# column_split <- function(data, light = FALSE, base_interval = "days"){}
```

```{r, eval=FALSE}
# subsetting(Gdata2, trap = "L", month_start = "05", month_end = "11")
```


### Processing the data into information relative to the whole trapping success

```{r, eval=FALSE}
# Creating a table in which we have relative values lateron
# For now using the Gdata_EBN dataset only
# Here, the package "reshape" is needed
Gdata_EBN_rel <- cast(aggregate(Gdata_EBN$value,
                       by = list(Gdata_EBN$spp, Gdata_EBN$date),
                       FUN = "sum",
                       na.rm = T),
                  Group.1 ~ Group.2,
                  value = "x",
                  "sum")

# Changing the species to front column and deleting the species column
rownames(Gdata_EBN_rel) <- Gdata_EBN_rel$Group.1
Gdata_EBN_rel <- Gdata_EBN_rel[,-1]
```

```{r, eval=FALSE}
test <- prop.table(as.matrix(Gdata_EBN_rel), 1)

# Here, the package "EcoSimR" is needed
pianka(test)
czekanowski(test)
```



`Gdata_EBN_2011_rel`
```{r, eval=FALSE}
# Creating a table in which we have relative values lateron
# For now using the Gdata_EBN_2011 dataset only
# Here, the package "reshape" is needed
Gdata_EBN_2011_rel <- cast(aggregate(Gdata_EBN_2011$value,
                       by = list(Gdata_EBN_2011$spp, Gdata_EBN_2011$date),
                       FUN = "sum",
                       na.rm = T),
                  Group.1 ~ Group.2,
                  value = "x",
                  "sum")

# Changing the species to front column and deleting the species column
rownames(Gdata_EBN_2011_rel) <- Gdata_EBN_2011_rel$Group.1
Gdata_EBN_2011_rel <- Gdata_EBN_2011_rel[,-1]
```
```{r, eval=FALSE}
test_2011 <- prop.table(as.matrix(Gdata_EBN_2011_rel), 1)

# Here, the package "EcoSimR" is needed
pianka(test_2011)
czekanowski(test_2011)
```


`Gdata_EBN_2012_rel`
```{r, eval=FALSE}
# Creating a table in which we have relative values lateron
# For now using the Gdata_EBN_2011 dataset only
# Here, the package "reshape" is needed
Gdata_EBN_2012_rel <- cast(aggregate(Gdata_EBN_2012$value,
                       by = list(Gdata_EBN_2012$spp, Gdata_EBN_2012$date),
                       FUN = "sum",
                       na.rm = T),
                  Group.1 ~ Group.2,
                  value = "x",
                  "sum")

# Changing the species to front column and deleting the species column
rownames(Gdata_EBN_2012_rel) <- Gdata_EBN_2012_rel$Group.1
Gdata_EBN_2012_rel <- Gdata_EBN_2012_rel[,-1]
```
```{r, eval=FALSE}
test_2012 <- prop.table(as.matrix(Gdata_EBN_2012_rel), 1)

# Here, the package "EcoSimR" is needed
pianka(test_2012)
czekanowski(test_2012)
```

```{r, eval=FALSE}
# pianka and czekanowski analysis for EBN_2011_rel as matrix
# Here, the package "EcoSimR" is needed


# pianka
m <- test_2011/rowSums(test_2011) # m == test_2011
pairwise_pi <- cbind(t(combn(nrow(m), 2)), 0)
    for (i in 1:nrow(pairwise_pi)) pairwise_pi[i, 3] <- sum(m[pairwise_pi[i, 
        1], ] * m[pairwise_pi[i, 2], ])/sqrt(sum(m[pairwise_pi[i, 1], 
        ]^2) * sum(m[pairwise_pi[i, 2], ]^2))
print(pairwise_pi)

# czekanowski
m <- test_2011/rowSums(test_2011) # m == test_2011
pairwise_cz <- cbind(t(combn(nrow(m), 2)), 0)
    for (i in 1:nrow(pairwise_cz)) pairwise_cz[i, 3] <- 1 - 0.5 * sum(abs((m[pairwise_cz[i, 
        1], ] - m[pairwise_cz[i, 2], ])))
print(pairwise_cz)


plot(pairwise_pi[,3], pairwise_cz[,3])
```

```{r, eval=FALSE}
# pianka and czekanowski analysis for EBN_2011_rel
# Here, the package "EcoSimR" is needed


# pianka
n <- Gdata_EBN_2011_rel/rowSums(Gdata_EBN_2011_rel)
pairwise <- cbind(t(combn(rownames(n), 2)), 0)
    for (i in 1:nrow(pairwise)) pairwise[i, 3] <- sum(n[pairwise[i, 
        1], ] * n[pairwise[i, 2], ])/sqrt(sum(n[pairwise[i, 1], 
        ]^2) * sum(n[pairwise[i, 2], ]^2))
print(pairwise)

# czekanowski
n <- Gdata_EBN_2011_rel/rowSums(Gdata_EBN_2011_rel)
pairwise_c <- cbind(t(combn(rownames(n), 2)), 0)
    for (i in 1:nrow(pairwise_c)) pairwise_c[i, 3] <- 1 - 0.5 * sum(abs((n[pairwise_c[i, 
        1], ] - n[pairwise_c[i, 2], ])))
print(pairwise_c)


plot(pairwise[,3], pairwise_c[,3])
```






- - - - - - - - - -

### Subsetting manually

Subsetting means to organize and cut the datatable so one only gets those information one needs for the upcoming analyses. For each subset we create one new datatable.


```{r, eval=FALSE}
# Creating a table for cooccur() function, Gdate_ss_EBN
Gdata_ss_EBN_co <- aggregate(Gdata_s1_EBN$value,
                       by = list(Gdata_s1_EBN$spp, Gdata_s1_EBN$date),
                       FUN = "sum",
                       na.rm = T)
Gdata_ss_EBN_coo <- cast(Gdata_ss_EBN_co,
                  Group.1 ~ Group.2,
                  value = "x",
                  "sum")

# Changing the species to front column and deleting the species column
rownames(Gdata_ss_EBN_coo) <- Gdata_ss_EBN_coo$Group.1
Gdata_ss_EBN_coo <- Gdata_ss_EBN_coo[,-1]
```


#### Subsetting by trap

The first subset `Gdata_s1` will contain the information about species trapped over time by trap type per site: `Gdata_s1_EBN` and `Gdata_s1_PP`

```{r, eval=FALSE}
# Creating a new "Gdata_s" subset datatable
Gdata_s <- Gdata2

# Creating a new "Gdata_s1" subset datatable
Gdata_s1 <- Gdata_s

# Deleting all rows, where no trap is specified
summary(Gdata_s1$trap)
Gdata_s1 <- subset(Gdata_s1, trap != "NA")
Gdata_s1 <- droplevels(Gdata_s1)
summary(Gdata_s1$trap)

# Creating the subset "Gdata_s1_EBN", containing only Costa Rican datapoints
summary(Gdata_s1$site)
Gdata_s1_EBN <- subset(Gdata_s1, site == "EBN")
Gdata_s1_EBN <- droplevels(Gdata_s1_EBN)
summary(Gdata_s1_EBN$site)

# Creating the subset "Gdata_s1_PP", containing only Peruvian datapoints
summary(Gdata_s1$site)
Gdata_s1_PP <- subset(Gdata_s1, site == "PP")
Gdata_s1_PP <- droplevels(Gdata_s1_PP)
summary(Gdata_s1_PP$site)
```


#### Substetting by year, only rainy season

We did not find any actual weatherdata about the rainy season at our sites yet. So, I take the general weather information about rainy season, which goes in EBN (Guanacaste province, Costa Rica) from May to November [Source, 8.9.15](http://costa-rica-guanacaste.com/guanacaste.html) and in Panguana (Peru) from October to April [Source, 8.9.15](http://www.zsm.mwn.de/panguana/).

Now we subset a datatable for a co-occurrence analysis by year and rainy season only, EBN only.

```{r, eval=FALSE}
Gdata_EBN <- subset(Gdata2, site == "EBN")
Gdata_EBN_rain <- subset(Gdata_EBN, month %in% c("05", "06", "07", "08", "09", "10"))
Gdata_EBN_rain <- droplevels(Gdata_EBN_rain)
summary(Gdata_EBN_rain$site)
summary(Gdata_EBN_rain$month)
```



### Converting the datatables into the format required by the co-occur() funktion

In a first step, we take the subsets `Gdata_s1_EBN`/ `Gdata_s1_PP` and create the tables formated for co-occurrence analyses.

```{r, eval=FALSE}
# Creating a table for cooccur() function, Gdate_s1_EBN
Gdata_s1_EBN_co <- aggregate(Gdata_s1_EBN,
                       by = list(Gdata_s1_EBN$spp, Gdata_s1_EBN$trap),
                       FUN = mean,
                       na.rm = T)
Gdata_s1_EBN_coo <- cast(Gdata_s1_EBN_co,
                  Group.1 ~ Group.2,
                  mean)

# Processing all NA values to "0" (absence of the species)
Gdata_s1_EBN_coo$L[Gdata_s1_EBN_coo$L != "1"]       <- 0
Gdata_s1_EBN_coo$N[Gdata_s1_EBN_coo$N != "1"]       <- 0
Gdata_s1_EBN_coo$PA[Gdata_s1_EBN_coo$PA != "1"]     <- 0
Gdata_s1_EBN_coo$Z[Gdata_s1_EBN_coo$Z != "1"]       <- 0
Gdata_s1_EBN_coo <- droplevels(Gdata_s1_EBN_coo)

# Controlling that values are numeric
str(Gdata_s1_EBN_coo)

# Changing the species to front column and deleting the species column
rownames(Gdata_s1_EBN_coo) <- Gdata_s1_EBN_coo$Group.1
Gdata_s1_EBN_coo <- Gdata_s1_EBN_coo[,-1]
```

```{r, eval=FALSE}
# Creating a table for cooccur() function, Gdate_s1_PP
Gdata_s1_PP_co <- aggregate(Gdata_s1_PP,
                       by = list(Gdata_s1_PP$spp, Gdata_s1_PP$trap),
                       FUN = mean,
                       na.rm = T)
Gdata_s1_PP_coo <- cast(Gdata_s1_PP_co,
                  Group.1 ~ Group.2,
                  mean)

# Processing all NA values to "0" (absence of the species)
Gdata_s1_PP_coo$L[Gdata_s1_PP_coo$L != "1"]       <- 0
Gdata_s1_PP_coo$N[Gdata_s1_PP_coo$N != "1"]       <- 0
Gdata_s1_PP_coo$PA[Gdata_s1_PP_coo$PA != "1"]     <- 0
Gdata_s1_PP_coo$Z[Gdata_s1_PP_coo$Z != "1"]       <- 0
Gdata_s1_PP_coo <- droplevels(Gdata_s1_PP_coo)

# Controlling that values are numeric
str(Gdata_s1_PP_coo)

# Changing the species to front column and deleting the species column
rownames(Gdata_s1_PP_coo) <- Gdata_s1_PP_coo$Group.1
Gdata_s1_PP_coo <- Gdata_s1_PP_coo[,-1]
```


Next, we create a table for running the co-occurrence analysis with the `Gdata_EBN` datatable.

```{r, eval=FALSE}
# Creating a table for cooccur() function, Gdate_s1_PP
Gdata_EBN_rain_co <- aggregate(Gdata_EBN_rain,
                       by = list(Gdata_EBN_rain$spp, Gdata_EBN_rain$year),
                       FUN = mean,
                       na.rm = T)
Gdata_EBN_rain_coo <- cast(Gdata_EBN_rain_co,
                  Group.1 ~ Group.2,
                  mean)

# Processing all NA values to "0" (absence of the species)
Gdata_EBN_rain_coo$"2007"[Gdata_EBN_rain_coo$"2007" != "1"]       <- 0
Gdata_EBN_rain_coo$"2008"[Gdata_EBN_rain_coo$"2008" != "1"]       <- 0
Gdata_EBN_rain_coo$"2009"[Gdata_EBN_rain_coo$"2009" != "1"]       <- 0
Gdata_EBN_rain_coo$"2010"[Gdata_EBN_rain_coo$"2010" != "1"]       <- 0
Gdata_EBN_rain_coo$"2011"[Gdata_EBN_rain_coo$"2011" != "1"]       <- 0
Gdata_EBN_rain_coo$"2012"[Gdata_EBN_rain_coo$"2012" != "1"]       <- 0
Gdata_EBN_rain_coo$"2013"[Gdata_EBN_rain_coo$"2013" != "1"]       <- 0
Gdata_EBN_rain_coo$"2014"[Gdata_EBN_rain_coo$"2014" != "1"]       <- 0
Gdata_EBN_rain_coo$"2015"[Gdata_EBN_rain_coo$"2015" != "1"]       <- 0
Gdata_EBN_rain_coo <- droplevels(Gdata_EBN_rain_coo)

# Controlling that values are numeric
str(Gdata_EBN_rain_coo)

# Changing the species to front column and deleting the species column
rownames(Gdata_EBN_rain_coo) <- Gdata_EBN_rain_coo$Group.1
Gdata_EBN_rain_coo <- Gdata_EBN_rain_coo[,-1]
```



## Analyses

Running the co-occurrence analysis by applying the cooccur() function with the cooccur R package.

### Co-occurrence within Arctiinae in EBN, Costa Rica, and Panguana, Peru, by trap type

The co-occurrence is analyzed by trap type.

```{r, eval=FALSE}
# Applying the Gdata_s1_EBN_coo datatable
cooccur.Gdata_s1_EBN <- cooccur(Gdata_s1_EBN_coo,
                             type = "spp_site",
                             thresh = T,
                             spp_names = T,
                             prob = "comb",
                             only_effects = F)
class(cooccur.Gdata_s1_EBN)

# Requesting a summary table for significant results of the co-occurrence analysis
summary(cooccur.Gdata_s1_EBN)

# Requesting a table of results, columns "p_lt" and "p_gt" are the probabilities
# that the two species do not co-occur less or more frequently than expected
prob.table(cooccur.Gdata_s1_EBN)

# Plotting the results
plot(cooccur.Gdata_s1_EBN, plotrand = T)

# Extracting co-occurrence information for one individual species
pair(mod=cooccur.Gdata_s1_EBN, spp = "8001")
# and plotting this individual information
pair.profile(cooccur.Gdata_s1_EBN)
```

```{r, eval=FALSE}
#######################################################################################
# As there are neither positive nor negative co-occurrences, we have to think about
# where it makes sense to carry on analysing!
summary(cooccur.Gdata_s1_EBN)
#######################################################################################
```


```{r, eval=FALSE}
# Applying the Gdata_s1_PP_coo datatable
cooccur.Gdata_s1_PP <- cooccur(Gdata_s1_PP_coo,
                             type = "spp_site",
                             thresh = T,
                             spp_names = T,
                             prob = "comb",
                             only_effects = F)
class(cooccur.Gdata_s1_PP)

# Requesting a summary table for significant results of the co-occurrence analysis
summary(cooccur.Gdata_s1_PP)

# Requesting a table of results, columns "p_lt" and "p_gt" are the probabilities
# that the two species do not co-occur less or more frequently than expected
prob.table(cooccur.Gdata_s1_PP)

# Plotting the results
plot(cooccur.Gdata_s1_PP, plotrand = T)

# Extracting co-occurrence information for one individual species
pair(mod=cooccur.Gdata_s1_PP, spp = "PP116")
# and plotting this individual information
pair.profile(cooccur.Gdata_s1_PP)
```

```{r, eval=FALSE}
#######################################################################################
# As there are neither positive nor negative co-occurrences, we have to think about
# where it makes sense to carry on analysing!
summary(cooccur.Gdata_s1_PP)
#######################################################################################
```


# Co-occurrence within Arctiinae in EBN, Costa Rica, by year and rainy season only

```{r, eval=FALSE}
# Applying the Gdata_s1_PP_coo datatable
cooccur.Gdata_EBN_rain <- cooccur(Gdata_EBN_rain_coo,
                             type = "spp_site",
                             thresh = T,
                             spp_names = T,
                             prob = "comb",
                             only_effects = F)
class(cooccur.Gdata_EBN_rain)

# Requesting a summary table for significant results of the co-occurrence analysis
summary(cooccur.Gdata_EBN_rain)

# Requesting a table of results, columns "p_lt" and "p_gt" are the probabilities
# that the two species do not co-occur less or more frequently than expected
prob.table(cooccur.Gdata_EBN_rain)

# Plotting the results
plot(cooccur.Gdata_EBN_rain, plotrand = T)

# Extracting co-occurrence information for one individual species
pair(mod=cooccur.Gdata_EBN_rain, spp = "5395")
# and plotting this individual information
pair.profile(cooccur.Gdata_EBN_rain)
```

```{r, eval=FALSE}
#######################################################################################
# We got a positive result!
# Now just the question how to read the results ;-)
# With Jonas' understanding: Taking spp "5395", it is unlikely to trap any other spp
# at the same time during the rainy season, except the 94 positively associatied spp.
# But as the other other species are not negatively associated, there might be a random
# effect to trap them at the same time as spp "5395".
summary(cooccur.Gdata_EBN_rain)
#######################################################################################
```



- - - - - - - - - -
# Results




